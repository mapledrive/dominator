Как написать ваш собственный виртуальный DOM
https://medium.com/devschacht/how-to-write-your-own-virtual-dom

Есть две вещи, которые вам необходимо знать для написания вашего собственного виртуального DOM. Вам даже не нужно погружаться в исходный код React или в исходный код любой другой имплементации виртуального DOM. Они такие большие и комплексные, но в действительности основная часть виртуального DOM может быть написана меньше чем за 50 строк кода. 50. Строк. Кода. !!!

Здесь заложено две концепции:

    Виртуальный DOM — любое представление настоящего DOM
    Когда мы что-то меняем в нашем виртуальном DOM дереве, мы создаем новое виртуальное дерево. Алгоритм сравнивает эти два дерева (старое и новое), находит разницу и вносит только необходимые минимальные изменения в настоящий DOM, чтобы он соответствовал виртуальному.

Это все! Давайте углубимся в каждую из этих концепций.
Представление нашего DOM дерева

Хорошо, в первую очередь нам нужно как-то хранить наше DOM дерево в памяти. И мы можем сделать это с помощью простых JS объектов. Предположим, у нас есть это дерево:

<ul class="list">
    <li>item 1</li>
    <li>item 2</li>
</ul>

Выглядит просто, не так ли? Как мы можем это представить с помощью простых JS объектов:

{
  type: 'ul', props: { 'class': 'list' }, children: [
    { type: 'li', props: {}, children: ['item 1'] },
    { type: 'li', props: {}, children: ['item 2'] }
  ]
}

Здесь вы можете заметить две вещи:

    Мы представляем DOM элементы в объектом виде

{ type: '…', props: { … }, children: [ … ] }

    Мы описываем текстовые ноды простыми JS строками

Но писать большие деревья таким способом довольно сложно. Так давайте напишем вспомогательную функцию, чтобы нам стало проще понимать структуру:

function h(type, props, …children) {
  return { type, props, children };
}

Теперь мы можем описывать наше DOM дерево в таком виде:

h('ul', { class: 'list' },
  h('li', {}, 'item 1'),
  h('li', {}, 'item 2'),
);

Выглядит намного чище, не правда ли? Но мы даже можем пойти дальше. Вы ведь слышали про JSX, не так ли? Да, я хотел бы применить его идеи тут. Так, как же он работает?



Если вы читали официальную документацию Babel к JSX здесь, вы знаете, что Babel транспилирует этот код:

<ul className=”list”>
  <li>item 1</li>
  <li>item 2</li>
</ul>

во что-то вроде этого:

React.createElement('ul', { className: 'list' },
  React.createElement('li', {}, 'item 1'),
  React.createElement('li', {}, 'item 2'),
);

Заметили сходство? Да, да… Если бы мы только могли просто заменить вызов React.createElement(...) на наш h(...)... Оказывается, мы можем, используя jsx pragma. Нам только требуется вставить похожую на комментарий строчку в начале нашего файла с исходным кодом.

/** @jsx helper */
<ul className=”list”>
  <li>item 1</li>
  <li>item 2</li>
</ul>

Хорошо, на самом деле она сообщает Babel: «Эй, скомпилируй этот jsx, но вместо React.createElement, подставь h». Здесь вы можете подставить что угодно вместо h. И это будет скомпилированно.

Итак, мы будем писать наш DOM таким образом:

/** @jsx h */
const a = (
  <ul className=”list”>
    <li>item 1</li>
    <li>item 2</li>
  </ul>
);

И это будет скомпилированно Babel в такой код:

const a = (
  h(‘ul’, { className: ‘list’ },
    h(‘li’, {}, ‘item 1’),
    h(‘li’, {}, ‘item 2’),
  );
);

Выполнение функции h вернет простой JS объект - наше представление виртуального DOM.

const a = (
  { type: ‘ul’, props: { className: ‘list’ }, children: [
    { type: ‘li’, props: {}, children: [‘item 1’] },
    { type: ‘li’, props: {}, children: [‘item 2’] }
  ] }
);

Попробуйте сами на JSFiddle (не забудьте указать Babel в качестве языка).
Применение нашего представления DOM

Хорошо, теперь мы имеем представление нашего DOM дерева в JS объекте, с нашей собственной структурой. Это круто, но нам нужно как-то создать настоящий DOM из него. Конечно, мы не можем просто применить наше представление к DOM.

Прежде всего давайте установим некоторые допущения и определимся с терминологией:

    Я буду писать все переменные, хранящие настоящие DOM ноды (элементы, текстовые ноды), начиная с $, таким образом $parent будет настоящим DOM элементом
    Виртуальное DOM представление будет храниться в переменной с именем node
    Как и в React, у вас может быть только одна корневая нода, все остальные ноды будут внутри

Теперь, когда мы со всем этим разобрались, давайте напишем функцию createElement(…), которая возьмет виртуальную DOM ноду и вернет настоящую DOM ноду. Забудьте пока о props и children, мы займемся ими позже:

function createElement(node) {
  if (typeof node === ‘string’) {
    return document.createTextNode(node);
  }
  return document.createElement(node.type);
}

Содержание функции такое, потому что у нас могут быть и текстовые ноды, являющиеся простыми JS строками, и элементы, представляющие собой JS объекты такого вида:

{ type: ‘…’, props: { … }, children: [ … ] }

Таким образом, мы можем передавать в нее как виртуальные текстовые ноды, так и ноды виртуальных элементов, и это будет работать.

Теперь давайте подумаем о детях: каждый из них также является текстовой нодой или элементом. Поэтому они также могут быть созданы с помощью нашей функции createElement(…). Вы чувствуете это? Попахивает рекурсией :)) Итак, мы можем вызвать createElement(…) для каждого из дочерних элементов, а затем appendChild() их в наш элемент следующим образом:

function createElement(node) {
  if (typeof node === ‘string’) {
    return document.createTextNode(node);
  }
  const $el = document.createElement(node.type);
  node.children
    .map(createElement)
    .forEach($el.appendChild.bind($el));
  return $el;
}

Вау, выглядит отлично. Давайте пока оставим в стороне props ноды. Мы поговорим о них позже. Они не нужны нам для базового понимания концепций виртуального DOM и только добавят сложности.
